// // scripts/generate-prisma.ts
// import { Project, InterfaceDeclaration, TypeAliasDeclaration } from "ts-morph";
// import { execSync } from "child_process";
// import { existsSync, mkdirSync, writeFileSync } from "fs";
// import { join } from "path";

// // Verificar e instalar dependencias faltantes
// function checkDependencies() {
//   const dependencies = {
//     production: ['prisma', '@prisma/client'],
//     dev: ['tsx', 'ts-node']
//   };

//   const toInstall = {
//     production: [] as string[],
//     dev: [] as string[]
//   };

//   // Verificar dependencias de producción
//   dependencies.production.forEach(dep => {
//     try {
//       require.resolve(dep);
//     } catch (e) {
//       toInstall.production.push(dep);
//     }
//   });

//   // Verificar dependencias de desarrollo
//   dependencies.dev.forEach(dep => {
//     try {
//       require.resolve(dep);
//     } catch (e) {
//       toInstall.dev.push(dep);
//     }
//   });

//   // Instalar solo lo necesario
//   if (toInstall.production.length > 0) {
//     console.log('Instalando dependencias de producción faltantes:', toInstall.production.join(', '));
//     execSync(`npm install ${toInstall.production.join(' ')} --legacy-peer-deps`, { stdio: 'inherit' });
//   }

//   if (toInstall.dev.length > 0) {
//     console.log('Instalando dependencias de desarrollo faltantes:', toInstall.dev.join(', '));
//     execSync(`npm install ${toInstall.dev.join(' ')} --save-dev --legacy-peer-deps`, { stdio: 'inherit' });
//   }

//   if (toInstall.production.length === 0 && toInstall.dev.length === 0) {
//     console.log('✓ Todas las dependencias ya están instaladas');
//   }
// }

// // Analizar tipos de TypeScript
// function parseTypes(filePath: string) {
//   const project = new Project();
//   const sourceFile = project.addSourceFileAtPath(filePath);
  
//   const models: Record<string, any> = {};
  
//   // Obtener interfaces y tipos
//   sourceFile.getInterfaces().forEach(intf => {
//     models[intf.getName()] = {
//       fields: intf.getProperties().map(prop => ({
//         name: prop.getName(),
//         type: prop.getType().getText(),
//         isArray: prop.getType().isArrayType()
//       }))
//     };
//   });

//   return models;
// }

// // Generar schema.prisma
// function generatePrismaSchema(models: any) {
//   let schema = `// Generated by Prisma Generator

// generator client {
//   provider = "prisma-client-js"
// }

// datasource db {
//   provider = "postgresql"
//   url      = env("DATABASE_URL")
// }

// `;
//   let relations = '';

//   for (const [modelName, modelData] of Object.entries(models)) {
//     schema += `model ${modelName} {\n`;
    
//     modelData.fields.forEach((field: any) => {
//       let fieldType = mapType(field.type);
//       let modifiers = '';
      
//       // Detectar campos especiales
//       if (field.name === 'id') {
//         modifiers += ' @id @default(uuid())';
//       } else if (field.name.includes('email')) {
//         modifiers += ' @unique';
//       } else if (field.name.includes('createdAt')) {
//         modifiers += ' @default(now())';
//       } else if (field.name.includes('updatedAt')) {
//         modifiers += ' @updatedAt';
//       }
      
//       // Manejar relaciones
//       if (models[fieldType] && field.isArray) {
//         relations += `  @@relation(fields: [${field.name}Id], references: [id])\n`;
//         schema += `  ${field.name}Id String\n`;
//       } else {
//         schema += `  ${field.name} ${fieldType}${modifiers}\n`;
//       }
//     });
    
//     schema += relations;
//     schema += '}\n\n';
//   }

//   return schema;
// }

// // Mapear tipos TypeScript → Prisma
// function mapType(tsType: string): string {
//   const typeMap: Record<string, string> = {
//     string: 'String',
//     number: 'Int',
//     boolean: 'Boolean',
//     Date: 'DateTime'
//   };
//   return typeMap[tsType] || tsType;
// }

// // Generar servicios
// function generateServices(models: any, outputDir: string) {
//   const servicesDir = join(outputDir, 'services');
//   if (!existsSync(servicesDir)) mkdirSync(servicesDir, { recursive: true });

//   // Archivo principal de Prisma
//   writeFileSync(join(servicesDir, 'prisma.ts'), `
// import { PrismaClient } from '@prisma/client';

// const globalForPrisma = global as unknown as { prisma: PrismaClient };

// export const prisma = globalForPrisma.prisma || new PrismaClient();

// if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
//   `.trim());

//   // Servicios por modelo
//   for (const model of Object.keys(models)) {
//     const serviceContent = `
// import { prisma } from './prisma';
// import type { ${model} } from '../types/types';

// export async function create${model}(data: Omit<${model}, 'id'>) {
//   return prisma.${model.toLowerCase()}.create({ data });
// }

// export async function get${model}ById(id: string) {
//   return prisma.${model.toLowerCase()}.findUnique({ where: { id } });
// }

// export async function update${model}(id: string, data: Partial<${model}>) {
//   return prisma.${model.toLowerCase()}.update({ where: { id }, data });
// }

// export async function delete${model}(id: string) {
//   return prisma.${model.toLowerCase()}.delete({ where: { id } });
// }

// export async function getAll${model}s() {
//   return prisma.${model.toLowerCase()}.findMany();
// }
//     `.trim();

//     writeFileSync(join(servicesDir, `${model.toLowerCase()}-service.ts`), serviceContent);
//   }
// }

// // Ejecución principal
// async function main() {
//   checkDependencies();
  
//   // const typesPath = join(process.cwd(), 'src', 'types', 'types.ts');
//   const typesPath = join(process.cwd(),  'types', 'types.ts');
//   if (!existsSync(typesPath)) throw new Error('types.ts no encontrado!');

//   const models = parseTypes(typesPath);
//   const prismaSchema = generatePrismaSchema(models);

//   // Crear estructura de Prisma
//   const prismaDir = join(process.cwd(), 'prisma');
//   if (!existsSync(prismaDir)) mkdirSync(prismaDir);
  
//   writeFileSync(join(prismaDir, 'schema.prisma'), prismaSchema);
//   generateServices(models, join(process.cwd(), 'src'));

//   // Ejecutar comandos de Prisma
//   console.log('Generando cliente de Prisma...');
//   execSync('npx prisma generate', { stdio: 'inherit' });
//   execSync('npx prisma migrate dev --name init', { stdio: 'inherit' });

//   console.log('✅ Generación completada!');
// }

// main().catch(console.error);

// scripts/generate-prisma.ts
// import { Project, InterfaceDeclaration } from "ts-morph";
// import { execSync } from "child_process";
// import { existsSync, mkdirSync, writeFileSync } from "fs";
// import { join } from "path";

// // Configuración
// const TYPES_FILE = join(process.cwd(), "src", "types", "types.ts");
// const PRISMA_DIR = join(process.cwd(), "prisma");
// const SERVICES_DIR = join(process.cwd(), "src", "services");

// // 1. Verificación de dependencias (versión mejorada)
// function checkDependencies() {
//   const requiredDeps = {
//     production: ["prisma", "@prisma/client"],
//     dev: ["tsx", "ts-node", "ts-morph", "@types/node"]
//   };

//   let needInstall = false;
//   const missingDeps = [];

//   for (const [type, deps] of Object.entries(requiredDeps)) {
//     for (const dep of deps) {
//       try {
//         require.resolve(dep);
//       } catch {
//         missingDeps.push(dep);
//         needInstall = true;
//       }
//     }
//   }

//   if (needInstall) {
//     console.log("Instalando dependencias faltantes:", missingDeps.join(", "));
//     execSync(`npm install ${missingDeps.join(" ")} --save-dev --legacy-peer-deps`, {
//       stdio: "inherit",
//     });
//   } else {
//     console.log("✓ Todas las dependencias están instaladas");
//   }
// }

// // 2. Mapeo de tipos TypeScript → Prisma (ampliado)
// function mapTypeToPrisma(tsType: string, isArray: boolean): string {
//   const typeMap: Record<string, string> = {
//     string: "String",
//     number: "Int",
//     boolean: "Boolean",
//     Date: "DateTime",
//     any: "Json",
//     unknown: "Json",
//   };

//   // Manejar arrays
//   if (isArray) {
//     return `${mapTypeToPrisma(tsType.replace("[]", "")), false}[]`;
//   }

//   // Manejar tipos unión (simplificado)
//   if (tsType.includes("|")) {
//     return "String"; // Por defecto para uniones
//   }

//   return typeMap[tsType] || "String"; // Default to String si no se reconoce
// }

// // 3. Generar schema.prisma (versión mejorada)
// function generatePrismaSchema(models: Record<string, any>) {
//   let schema = `// Generated automatically from your TypeScript types

// generator client {
//   provider = "prisma-client-js"
//   previewFeatures = ["clientExtensions"]
// }

// datasource db {
//   provider = "postgresql"
//   url      = env("DATABASE_URL")
// }

// `;

//   for (const [modelName, modelData] of Object.entries(models)) {
//     schema += `model ${modelName} {\n`;

//     // Campo ID por defecto si no existe
//     if (!modelData.fields.some((f: any) => f.name === "id")) {
//       schema += `  id    String  @id @default(uuid())\n`;
//     }

//     modelData.fields.forEach((field: any) => {
//       const prismaType = mapTypeToPrisma(field.type, field.isArray);
//       let modifiers = "";

//       // Modificadores especiales
//       if (field.name === "id") {
//         modifiers = " @id @default(uuid())";
//       } else if (field.name.includes("email")) {
//         modifiers = " @unique";
//       } else if (field.name.match(/createdAt|created_date/gi)) {
//         modifiers = " @default(now())";
//       } else if (field.name.match(/updatedAt|updated_date/gi)) {
//         modifiers = " @updatedAt";
//       }

//       // Relaciones (simplificado)
//       if (models[field.type] && field.isArray) {
//         schema += `  ${field.name} ${field.type}[] @relation(fields: [${field.name}Id], references: [id])\n`;
//         schema += `  ${field.name}Id String?\n`;
//       } else {
//         schema += `  ${field.name} ${prismaType}${modifiers}\n`;
//       }
//     });

//     schema += "}\n\n";
//   }

//   return schema;
// }

// // 4. Analizar tipos de TypeScript (versión robusta)
// function parseTypescriptTypes() {
//   if (!existsSync(TYPES_FILE)) {
//     throw new Error(`Archivo de tipos no encontrado en: ${TYPES_FILE}`);
//   }

//   const project = new Project();
//   const sourceFile = project.addSourceFileAtPath(TYPES_FILE);
//   const models: Record<string, any> = {};

//   // Procesar interfaces
//   sourceFile.getInterfaces().forEach((interfaceDec) => {
//     const modelName = interfaceDec.getName();
//     models[modelName] = {
//       fields: interfaceDec.getProperties().map((property) => {
//         const type = property.getType();
//         return {
//           name: property.getName(),
//           type: type.getText(property),
//           isArray: type.isArrayType(),
//           isOptional: property.hasQuestionToken(),
//         };
//       }),
//     };
//   });

//   // Procesar tipos (type aliases)
//   sourceFile.getTypeAliases().forEach((typeAlias) => {
//     const typeName = typeAlias.getName();
//     if (!models[typeName]) {
//       models[typeName] = {
//         fields: [],
//       };
//     }
//   });

//   return models;
// }

// // 5. Generar servicios (versión mejorada)
// function generatePrismaServices(models: Record<string, any>) {
//   if (!existsSync(SERVICES_DIR)) {
//     mkdirSync(SERVICES_DIR, { recursive: true });
//   }

//   // Archivo principal de Prisma
//   writeFileSync(
//     join(SERVICES_DIR, "prisma.ts"),
//     `import { PrismaClient } from '@prisma/client';

// const globalForPrisma = globalThis as unknown as { prisma: PrismaClient };

// export const prisma = globalForPrisma.prisma || new PrismaClient();

// if (process.env.NODE_ENV !== 'production') {
//   globalForPrisma.prisma = prisma;
// }

// export default prisma;
// `
//   );

//   // Generar un servicio por modelo
//   Object.keys(models).forEach((modelName) => {
//     const serviceContent = `import { prisma } from './prisma';
// import type { ${modelName} } from '../types/types';

// export const ${modelName.toLowerCase()}Service = {
//   async create(data: Omit<${modelName}, 'id'>): Promise<${modelName}> {
//     return prisma.${modelName.toLowerCase()}.create({ data });
//   },

//   async findById(id: string): Promise<${modelName} | null> {
//     return prisma.${modelName.toLowerCase()}.findUnique({ where: { id } });
//   },

//   async findAll(): Promise<${modelName}[]> {
//     return prisma.${modelName.toLowerCase()}.findMany();
//   },

//   async update(id: string, data: Partial<${modelName}>): Promise<${modelName}> {
//     return prisma.${modelName.toLowerCase()}.update({ where: { id }, data });
//   },

//   async delete(id: string): Promise<${modelName}> {
//     return prisma.${modelName.toLowerCase()}.delete({ where: { id } });
//   },
// };
// `;

//     writeFileSync(
//       join(SERVICES_DIR, `${modelName.toLowerCase()}.service.ts`),
//       serviceContent
//     );
//   });
// }

// // Ejecución principal
// async function main() {
//   try {
//     console.log("🔍 Verificando dependencias...");
//     checkDependencies();

//     console.log("📖 Analizando tipos TypeScript...");
//     const models = parseTypescriptTypes();
//     console.log(`✅ Modelos detectados: ${Object.keys(models).join(", ")}`);

//     console.log("🛠️ Generando esquema Prisma...");
//     if (!existsSync(PRISMA_DIR)) {
//       mkdirSync(PRISMA_DIR);
//     }
//     const prismaSchema = generatePrismaSchema(models);
//     writeFileSync(join(PRISMA_DIR, "schema.prisma"), prismaSchema);

//     console.log("🧰 Generando servicios Prisma...");
//     generatePrismaServices(models);

//     console.log("🚀 Generando cliente Prisma...");
//     execSync("npx prisma generate", { stdio: "inherit" });

//     console.log("🔃 Aplicando migraciones iniciales...");
//     execSync("npx prisma migrate dev --name init", { stdio: "inherit" });

//     console.log("🎉 ¡Generación completada con éxito!");
//   } catch (error) {
//     console.error("❌ Error durante la generación:", error);
//     process.exit(1);
//   }
// }

// main();

// import { Project, InterfaceDeclaration, TypeAliasDeclaration } from "ts-morph";
// import { execSync } from "child_process";
// import { existsSync, mkdirSync, writeFileSync, readFileSync } from "fs";
// import { join } from "path";

// // Configuración
// const TYPES_FILE = join(process.cwd(),  "types", "types.ts");
// const PRISMA_DIR = join(process.cwd(), "prisma");
// const SERVICES_DIR = join(process.cwd(),  "services");

// // 1. Verificación de dependencias mejorada
// function checkDependencies() {
//   const requiredDeps = {
//     production: [ "@prisma/client"],
//     dev: ["prisma","tsx", "ts-node", "ts-morph", "@types/node"]
//   };

//   // Verificar qué dependencias faltan
//   const missingDeps = {
//     production: [] as string[],
//     dev: [] as string[]
//   };

//   Object.entries(requiredDeps).forEach(([type, deps]) => {
//     deps.forEach(dep => {
//       try {
//         require.resolve(dep);
//       } catch {
//         missingDeps[type as 'production' | 'dev'].push(dep);
//       }
//     });
//   });

//   // Instalar solo lo que falta
//   if (missingDeps.production.length > 0) {
//     console.log("Instalando dependencias de producción faltantes:", missingDeps.production.join(", "));
//     execSync(`npm install ${missingDeps.production.join(" ")} --legacy-peer-deps`, { stdio: "inherit" });
//   }

//   if (missingDeps.dev.length > 0) {
//     console.log("Instalando dependencias de desarrollo faltantes:", missingDeps.dev.join(", "));
//     execSync(`npm install ${missingDeps.dev.join(" ")} --save-dev --legacy-peer-deps`, { stdio: "inherit" });
//   }

//   if (missingDeps.production.length === 0 && missingDeps.dev.length === 0) {
//     console.log("✓ Todas las dependencias están instaladas");
//   } else {
//     console.log("✓ Dependencias instaladas correctamente");
//   }
// }

// // 2. Mapeo de tipos mejorado
// function mapTypeToPrisma(tsType: string, isArray: boolean): string {
//   const typeMap: Record<string, string> = {
//     string: "String",
//     number: "Decimal", // Mejor para campos monetarios
//     boolean: "Boolean",
//     Date: "DateTime",
//     any: "Json",
//     unknown: "Json",
//     bigint: "BigInt"
//   };

//   // Limpiar el tipo (remover null|undefined de uniones)
//   const cleanType = tsType.replace(/\s*\|\s*(null|undefined)/g, "").trim();

//   // Manejar arrays
//   if (isArray) {
//     return `${mapTypeToPrisma(cleanType.replace("[]", ""), false)}[]`;
//   }

//   // Manejar tipos unión complejos
//   if (cleanType.includes("|")) {
//     const typesInUnion = cleanType.split("|").map(t => t.trim());
//     if (typesInUnion.every(t => ["string", "number"].includes(t))) {
//       return "String"; // Default seguro para uniones básicas
//     }
//     return "Json"; // Para uniones complejas
//   }

//   // Manejar tipos personalizados (type aliases)
//   if (cleanType.match(/^[A-Z][a-zA-Z0-9]*$/) && !typeMap[cleanType]) {
//     return cleanType; // Asume que es un modelo relacionado
//   }

//   return typeMap[cleanType] || "String";
// }

// // 3. Generación de schema mejorada
// function generatePrismaSchema(models: Record<string, any>) {
//   let schema = `// Generated automatically from your TypeScript types
// // DO NOT EDIT MANUALLY

// generator client {
//   provider = "prisma-client-js"
//   previewFeatures = ["clientExtensions"]
// }

// datasource db {
//   provider = "postgresql"
//   url      = env("DATABASE_URL")
// }

// `;

//   // Primero generar enums y tipos complejos
//   Object.entries(models).forEach(([name, modelData]) => {
//     if (modelData.isEnum) {
//       schema += `enum ${name} {\n`;
//       modelData.values.forEach((value: string) => {
//         schema += `  ${value}\n`;
//       });
//       schema += "}\n\n";
//     }
//   });

//   // Luego generar modelos
//   Object.entries(models).forEach(([name, modelData]) => {
//     if (modelData.isEnum) return;

//     schema += `model ${name} {\n`;

//     // Campo ID por defecto si no existe
//     const hasId = modelData.fields.some((f: any) => f.name === "id");
//     if (!hasId) {
//       schema += `  id    String  @id @default(uuid())\n`;
//     }

//     modelData.fields.forEach((field: any) => {
//       const prismaType = mapTypeToPrisma(field.type, field.isArray);
//       let modifiers = "";

//       // Modificadores especiales
//       if (field.name === "id") {
//         modifiers = " @id @default(uuid())";
//       } else if (field.name.toLowerCase().includes("email")) {
//         modifiers = " @unique";
//       } else if (field.name.match(/createdAt|created_date/gi)) {
//         modifiers = " @default(now())";
//       } else if (field.name.match(/updatedAt|updated_date/gi)) {
//         modifiers = " @updatedAt";
//       } else if (field.isOptional) {
//         modifiers = "?";
//       }

//       // Relaciones
//       if (models[field.type] && !models[field.type]?.isEnum && field.isArray) {
//         schema += `  ${field.name} ${field.type}[] @relation(fields: [${field.name}Id], references: [id])\n`;
//         schema += `  ${field.name}Id String${modifiers.replace("?", "")}\n`;
//       } else if (models[field.type] && !models[field.type]?.isEnum) {
//         schema += `  ${field.name} ${field.type}? @relation(fields: [${field.name}Id], references: [id])\n`;
//         schema += `  ${field.name}Id String${modifiers.replace("?", "")}\n`;
//       } else {
//         schema += `  ${field.name} ${prismaType}${modifiers}\n`;
//       }
//     });

//     schema += "}\n\n";
//   });

//   return schema;
// }

// // 4. Análisis de tipos robusto
// function parseTypescriptTypes() {
//   // Verificar existencia del archivo
//   if (!existsSync(TYPES_FILE)) {
//     throw new Error(`❌ Archivo de tipos no encontrado en: ${TYPES_FILE}\nPor favor, crea el archivo con tus interfaces/types.`);
//   }

//   try {
//     // Verificar que el archivo no esté vacío
//     const fileContent = readFileSync(TYPES_FILE, "utf-8");
//     if (fileContent.trim().length === 0) {
//       throw new Error(`❌ El archivo ${TYPES_FILE} está vacío`);
//     }

//     const project = new Project();
//     const sourceFile = project.addSourceFileAtPath(TYPES_FILE);
//     const models: Record<string, any> = {};

//     // Procesar enums
//     sourceFile.getEnums().forEach(enumDec => {
//       models[enumDec.getName()] = {
//         isEnum: true,
//         values: enumDec.getMembers().map(member => member.getName())
//       };
//     });

//     // Procesar interfaces
//     sourceFile.getInterfaces().forEach(interfaceDec => {
//       const modelName = interfaceDec.getName();
//       models[modelName] = {
//         fields: interfaceDec.getProperties().map(property => {
//           const type = property.getType();
//           const typeText = type.getText(property);
//           return {
//             name: property.getName(),
//             type: typeText,
//             isArray: type.isArrayType(),
//             isOptional: property.hasQuestionToken()
//           };
//         })
//       };
//     });

//     // Procesar type aliases (para relaciones)
//     sourceFile.getTypeAliases().forEach(typeAlias => {
//       const typeName = typeAlias.getName();
//       if (!models[typeName]) {
//         const typeText = typeAlias.getType().getText();
//         // Detectar si es un tipo unión que podría ser enum
//         if (typeText.includes("|") && typeText.split("|").every(t => t.match(/^['"]/))) {
//           models[typeName] = {
//             isEnum: true,
//             values: typeText.split("|").map(t => t.trim().replace(/['"]/g, ""))
//           };
//         }
//       }
//     });

//     if (Object.keys(models).length === 0) {
//       throw new Error("❌ No se encontraron interfaces, types o enums en el archivo types.ts");
//     }

//     return models;
//   } catch (error) {
//     if (error instanceof Error) {
//       throw new Error(`❌ Error al analizar types.ts: ${error.message}`);
//     }
//     throw new Error("❌ Error desconocido al analizar types.ts");
//   }
// }

// // 5. Generación de servicios mejorada
// function generatePrismaServices(models: Record<string, any>) {
//   try {
//     if (!existsSync(SERVICES_DIR)) {
//       mkdirSync(SERVICES_DIR, { recursive: true });
//       console.log(`✓ Carpeta de servicios creada: ${SERVICES_DIR}`);
//     }

//     // Archivo principal de Prisma
//     const prismaClientContent = `// Configuración del cliente Prisma
// import { PrismaClient } from '@prisma/client';

// const globalForPrisma = globalThis as unknown as { 
//   prisma: PrismaClient | undefined 
// };

// export const prisma = globalForPrisma.prisma ?? new PrismaClient({
//   log: process.env.NODE_ENV === 'development' 
//     ? ['query', 'error', 'warn'] 
//     : ['error']
// });

// if (process.env.NODE_ENV !== 'production') {
//   globalForPrisma.prisma = prisma;
// }

// export default prisma;
// `;
//     writeFileSync(join(SERVICES_DIR, "prisma.ts"), prismaClientContent);

//     // Generar un servicio por modelo
//     Object.entries(models).forEach(([modelName, modelData]) => {
//       if (modelData.isEnum) return; // Saltar enums

//       const serviceContent = `// Servicio para el modelo ${modelName}
// import { prisma } from './prisma';
// import type { ${modelName} } from '../types/types';

// export const ${modelName.toLowerCase()}Service = {
//   // Crear un nuevo registro
//   async create(data: Omit<${modelName}, 'id'>): Promise<${modelName}> {
//     return prisma.${modelName.toLowerCase()}.create({ 
//       data,
//       include: {
//         ${modelData.fields
//           .filter((f: any) => models[f.type] && !models[f.type]?.isEnum)
//           .map((f: any) => f.name)
//           .join(",\n        ")}
//       }
//     });
//   },

//   // Obtener por ID
//   async findById(id: string): Promise<${modelName} | null> {
//     return prisma.${modelName.toLowerCase()}.findUnique({ 
//       where: { id },
//       include: {
//         ${modelData.fields
//           .filter((f: any) => models[f.type] && !models[f.type]?.isEnum)
//           .map((f: any) => f.name)
//           .join(",\n        ")}
//       }
//     });
//   },

//   // Obtener todos los registros
//   async findAll(): Promise<${modelName}[]> {
//     return prisma.${modelName.toLowerCase()}.findMany({
//       include: {
//         ${modelData.fields
//           .filter((f: any) => models[f.type] && !models[f.type]?.isEnum)
//           .map((f: any) => f.name)
//           .join(",\n        ")}
//       }
//     });
//   },

//   // Actualizar registro
//   async update(id: string, data: Partial<${modelName}>): Promise<${modelName}> {
//     return prisma.${modelName.toLowerCase()}.update({ 
//       where: { id },
//       data,
//       include: {
//         ${modelData.fields
//           .filter((f: any) => models[f.type] && !models[f.type]?.isEnum)
//           .map((f: any) => f.name)
//           .join(",\n        ")}
//       }
//     });
//   },

//   // Eliminar registro
//   async delete(id: string): Promise<${modelName}> {
//     return prisma.${modelName.toLowerCase()}.delete({ 
//       where: { id },
//       include: {
//         ${modelData.fields
//           .filter((f: any) => models[f.type] && !models[f.type]?.isEnum)
//           .map((f: any) => f.name)
//           .join(",\n        ")}
//       }
//     });
//   },

//   // Métodos adicionales pueden ir aquí
// };
// `;
//       writeFileSync(
//         join(SERVICES_DIR, `${modelName.toLowerCase()}.service.ts`),
//         serviceContent
//       );
//     });

//     console.log(`✓ Servicios generados en: ${SERVICES_DIR}`);
//   } catch (error) {
//     throw new Error(`❌ Error al generar servicios: ${error instanceof Error ? error.message : String(error)}`);
//   }
// }

// // Ejecución principal con manejo mejorado de errores
// async function main() {
//   try {
//     console.log("🔍 Iniciando generación de Prisma y servicios...");

//     // 1. Verificar dependencias
//     console.log("\n🔧 Verificando dependencias...");
//     // checkDependencies();

//     // 2. Analizar tipos
//     console.log("\n📖 Analizando tipos TypeScript...");
//     const models = parseTypescriptTypes();
//     console.log(`✅ Modelos detectados: ${Object.keys(models).filter(m => !models[m].isEnum).join(", ")}`);
//     if (Object.keys(models).some(m => models[m].isEnum)) {
//       console.log(`✅ Enums detectados: ${Object.keys(models).filter(m => models[m].isEnum).join(", ")}`);
//     }

//     // 3. Generar esquema Prisma
//     console.log("\n🛠️ Generando esquema Prisma...");
//     if (!existsSync(PRISMA_DIR)) {
//       mkdirSync(PRISMA_DIR);
//       console.log(`✓ Carpeta Prisma creada: ${PRISMA_DIR}`);
//     }
//     const prismaSchema = generatePrismaSchema(models);
//     writeFileSync(join(PRISMA_DIR, "schema.prisma"), prismaSchema);
//     console.log("✓ Esquema Prisma generado correctamente");

//     // 4. Generar servicios
//     console.log("\n🧰 Generando servicios...");
//     generatePrismaServices(models);

//     // 5. Generar cliente Prisma
//     console.log("\n🚀 Generando cliente Prisma...");
//     execSync("npx prisma generate", { stdio: "inherit" });

//     // 6. Aplicar migraciones iniciales
//     console.log("\n🔃 Aplicando migraciones iniciales...");
//     execSync("npx prisma migrate dev --name init", { stdio: "inherit" });

//     console.log("\n🎉 ¡Generación completada con éxito!");
//   } catch (error) {
//     console.error("\n❌ Error durante la generación:");
//     if (error instanceof Error) {
//       console.error(error.message);
//       if (error.stack) {
//         console.error("\nStack trace:");
//         console.error(error.stack.split("\n").slice(0, 5).join("\n"));
//       }
//     } else {
//       console.error(error);
//     }
//     console.log("\n💡 Soluciones posibles:");
//     console.log("- Verifica que el archivo src/types/types.ts existe y contiene interfaces/types válidos");
//     console.log("- Asegúrate de tener Node.js v22+ instalado");
//     console.log("- Intenta ejecutar 'npm install' manualmente si hay problemas de dependencias");
//     process.exit(1);
//   }
// }

// main();

// const fs = require('fs/promises');
// const path = require('path');
// const { exec } = require('child_process');
// const { promisify } = require('util');

// import { Project, InterfaceDeclaration } from "ts-morph";
// import { exec } from "child_process";
// import fs from 'fs/promises';
// import path from "path";
// import { promisify }  from "util";

// const execAsync = promisify(exec);

// const PROJECT_ROOT = process.cwd();
// const PRISMA_DIR = path.join(PROJECT_ROOT, 'prisma');
// const TYPES_FILE = path.join(PROJECT_ROOT,'types', 'types.ts');
// const SERVICES_DIR = path.join(PROJECT_ROOT, 'services');
// const LIB_DIR = path.join(PROJECT_ROOT, 'lib');
// const PRISMA_CLIENT_FILE = path.join(LIB_DIR, 'prisma.ts');

// // Modelos extraídos de types.ts
// let models = [];

// // === 1. Verificar si Prisma está inicializado ===
// async function ensurePrismaInitialized() {
//   try {
//     await fs.access(path.join(process.cwd(), 'prisma'));
//     console.log('✅ Prisma ya está inicializado');
//   } catch (error) {
//     if (error.code === 'ENOENT') {
//       console.log('🔧 Inicializando Prisma...');
//       await execAsync('npx prisma init');
//       console.log('✅ Prisma inicializado');
//     } else {
//       throw error; // Otros errores no relacionados con la carpeta
//     }
//   }
// }

// // === 2. Leer y parsear types.ts ===
// // async function parseTypesFile() {
// //   try {
// //     const data = await fs.readFile(TYPES_FILE, 'utf-8');
// //     console.log(`✅ Archivo types.ts leído correctamente`);

// //     // Regex para capturar interfaces y type aliases que tengan cuerpo { ... }
// //     // const typeInterfaceRegex = /(interface|type)\s+(\w+)\s*(?:=)?\s*{([\s\S]*?)}/g;
// //     const typeInterfaceRegex = /(interface|type)\s+(\w+)\s+{([\s\S]*?)}/g;
// //     let match;

// //     while ((match = typeInterfaceRegex.exec(data)) !== null) {
// //       const typeName = match[2]; // Nombre del tipo o interfaz
// //       const body = match[3];     // Contenido entre llaves

// //       // Procesar solo si parece un objeto estructurado
// //       if (body.trim()) {
// //         const fields = body
// //           .split('\n')
// //           .map(line => line.trim())
// //           .filter(line => line && !line.startsWith('}'))
// //           .map(line => {
// //             const [name, type] = line.split(':').map(s => s.trim());
// //             return { name, type: type.replace(/;$/, '') };
// //           });

// //         // Solo agregar modelos con campos definidos
// //         if (fields.length > 0) {
// //           models.push({ modelName: typeName, fields });
// //         } else {
// //           console.warn(`⚠️ Tipo "${typeName}" no tiene campos estructurados, se ignora.`);
// //         }
// //       } else {
// //         console.warn(`⚠️ Tipo "${typeName}" está vacío o no es un objeto estructurado.`);
// //       }
// //     }

// //     console.log(`✅ Modelos encontrados: ${models.map(m => m.modelName).join(', ')}`);
// //   } catch (error) {
// //     console.error('❌ No se encontró types.ts o tiene errores de sintaxis', error);
// //     process.exit(1);
// //   }
// // }
// async function parseTypesFile() {
//   try {
//     const data = await fs.readFile(TYPES_FILE, 'utf-8');
//     console.log(`✅ Archivo types.ts leído correctamente`);

//     // Regex mejorado para capturar interfaces y type aliases con cuerpo { ... }
//     const typeInterfaceRegex = /(interface|type)\s+(\w+)\s*(?:=)?\s*{([\s\S]*?)}/g;
//     let match;

//     while ((match = typeInterfaceRegex.exec(data)) !== null) {
//       const typeName = match[2]; // Nombre del tipo o interfaz
//       const body = match[3];     // Contenido entre llaves

//       if (body.trim()) {
//         const fields = body
//           .split('\n')
//           .map(line => line.trim())
//           .filter(line => line && !line.startsWith('}'))
//           .map(line => {
//             const [name, type] = line.split(':').map(s => s.trim());
//             const isOptional = name.endsWith('?');
//             const fieldName = isOptional ? name.slice(0, -1) : name;
//             return { 
//               name: fieldName, 
//               type: type.replace(/;$/, ''), 
//               optional: isOptional 
//             };
//           });

//         models.push({ modelName: typeName, fields });
//       } else {
//         console.warn(`⚠️ Tipo "${typeName}" está vacío o no es un objeto estructurado.`);
//       }
//     }

//     console.log(`✅ Modelos encontrados: ${models.map(m => m.modelName).join(', ')}`);
//   } catch (error) {
//     console.error('❌ No se encontró types.ts o tiene errores de sintaxis', error);
//     process.exit(1);
//   }
// }


// // === 3. Generar schema.prisma ===
// // async function generatePrismaSchema() {
// //   const schemaPath = path.join(PRISMA_DIR, 'schema.prisma');
// //   let schemaContent = `
// // // schema.prisma - Generado automáticamente
// // datasource db {
// //   provider = "postgresql" // Cambiar según tu base de datos
// //   url      = env("DATABASE_URL")
// // }

// // generator client {
// //   provider = "prisma-client-js"
// // }

// // // === Modelos generados ===
// // `;

// //   models.forEach(model => {
// //     schemaContent += `model ${model.modelName} {\n`;
    
// //     model.fields.forEach(field => {
// //       const prismaType = mapToPrismaType(field.type);
// //       schemaContent += `  ${field.name} ${prismaType}\n`;
// //     });

// //     schemaContent += '}\n\n';
// //   });

// //   await fs.writeFile(schemaPath, schemaContent);
// //   console.log('✅ schema.prisma generado');
// // }

// async function generatePrismaSchema() {
//   const schemaPath = path.join(PRISMA_DIR, 'schema.prisma');
//   let schemaContent = `
// // schema.prisma - Generado automáticamente
// datasource db {
//   provider = "postgresql"
//   url      = env("DATABASE_URL")
// }

// generator client {
//   provider = "prisma-client-js"
// }

// // === Modelos generados ===
// `;

//   models.forEach(model => {
//     schemaContent += `model ${model.modelName} {\n`;

//     // Asegurar que haya un campo id con @id
//     const idField = model.fields.find(f => f.name === 'id');
//     if (!idField) {
//       schemaContent += `  id String @id\n`;
//     }

//     model.fields.forEach(field => {
//       if (field.name === 'id') {
//         schemaContent += `  id String @id\n`;
//       } else {
//         const prismaType = mapToPrismaType(field.type);
//         const optional = field.optional ? '?' : '';
//         schemaContent += `  ${field.name} ${prismaType}${optional}\n`;
//       }
//     });

//     schemaContent += '}\n\n';
//   });

//   await fs.writeFile(schemaPath, schemaContent);
//   console.log('✅ schema.prisma generado');
// }

// // === 4. Mapear tipos de TS a Prisma ===
// // function mapToPrismaType(tsType) {
// //   const mapping = {
// //     'string': 'String',
// //     'number': 'Int',
// //     'boolean': 'Boolean',
// //     'Date': 'DateTime'
// //   };
  
// //   // Detectar relaciones (ej: userId: number)
// //   if (tsType.endsWith('Id') && models.some(m => m.modelName === tsType.replace('Id', ''))) {
// //     return `Int @relation(name: "${tsType.replace('Id', '')}")`;
// //   }
  
// //   return mapping[tsType] || 'String'; // Por defecto
// // }
// function mapToPrismaType(tsType) {
//   const mapping = {
//     string: 'String',
//     number: 'Int',
//     boolean: 'Boolean',
//     Date: 'DateTime',
//     stringArray: 'String[]', // Ejemplo de tipo personalizado
//     numberArray: 'Int[]'
//   };

//   return mapping[tsType] || 'String';
// }

// // === 5. Crear servicios CRUD ===
// // async function generateServices() {
// //   await fs.mkdir(SERVICES_DIR, { recursive: true });
  
// //   for (const model of models) {
// //     const { modelName, fields } = model;
// //     const lowerName = modelName.toLowerCase();
    
// //     const serviceContent = `
// // import { prisma } from '../lib/prisma';

// // export const getAll${modelName}s = async () => {
// //   return await prisma.${lowerName}.findMany();
// // };

// // export const get${modelName}ById = async (id: number) => {
// //   return await prisma.${lowerName}.findUnique({ where: { id } });
// // };

// // export const create${modelName} = async (data: any) => {
// //   return await prisma.${lowerName}.create({ data });
// // };

// // export const update${modelName} = async (id: number, data: any) => {
// //   return await prisma.${lowerName}.update({ where: { id }, data });
// // };

// // export const delete${modelName} = async (id: number) => {
// //   return await prisma.${lowerName}.delete({ where: { id } });
// // };
// //     `;
    
// //     await fs.writeFile(path.join(SERVICES_DIR, `${modelName}Service.ts`), serviceContent.trim());
// //   }
  
// //   // Crear index.ts para exportar todos los servicios
// //   const indexContent = models.map(model => 
// //     `export * from './${model.modelName}Service';`
// //   ).join('\n');
  
// //   await fs.writeFile(path.join(SERVICES_DIR, 'index.ts'), indexContent);
// //   console.log('✅ Servicios generados');
// // }
// async function generateServices() {
//   await fs.mkdir(SERVICES_DIR, { recursive: true });
  
//   for (const model of models) {
//     const { modelName, fields } = model;
//     const lowerName = modelName.toLowerCase();
    
//     const serviceContent = `
// import { prisma } from '../lib/prisma';

// // Tipos generados
// export type ${modelName} = {
//   id: string;
//   ${fields
//     .filter(f => f.name !== 'id')
//     .map(f => `${f.name}${f.optional ? '?' : ''}: ${mapToPrismaType(f.type).replace('[]', '[] | null')}`)
//     .join(';\n  ')}
// };

// // Servicios CRUD
// export const getAll${modelName}s = async () => {
//   return await prisma.${lowerName}.findMany();
// };

// export const get${modelName}ById = async (id: string) => {
//   return await prisma.${lowerName}.findUnique({ where: { id } });
// };

// export const create${modelName} = async (data: Omit<${modelName}, 'id'>) => {
//   return await prisma.${lowerName}.create({ data });
// };

// export const update${modelName} = async (id: string, data: Partial<${modelName}>) => {
//   return await prisma.${lowerName}.update({ where: { id }, data });
// };

// export const delete${modelName} = async (id: string) => {
//   return await prisma.${lowerName}.delete({ where: { id } });
// };
//     `;
    
//     await fs.writeFile(path.join(SERVICES_DIR, `${modelName}Service.ts`), serviceContent.trim());
//   }
  
//   // Crear index.ts para exportar todos los servicios
//   const indexContent = models.map(model => 
//     `export * from './${model.modelName}Service';`
//   ).join('\n');
  
//   await fs.writeFile(path.join(SERVICES_DIR, 'index.ts'), indexContent);
//   console.log('✅ Servicios generados');
// }

// // === 6. Crear cliente de Prisma ===
// async function createPrismaClient() {
//   const clientContent = `
// import { PrismaClient } from '@prisma/client';

// const prisma = new PrismaClient();

// export { prisma };
//   `;
  
//   await fs.mkdir(LIB_DIR, { recursive: true });
//   await fs.writeFile(PRISMA_CLIENT_FILE, clientContent.trim());
//   console.log('✅ Cliente de Prisma creado');
// }

// // === 7. Ejecutar el flujo ===
// async function run() {
//   try {
//     await ensurePrismaInitialized();
//     await parseTypesFile();
//     await generatePrismaSchema();
//     await createPrismaClient();
//     await generateServices();
    
//     // Ejecutar prisma generate
//     await execAsync('npx prisma generate');
//     console.log('✅ Prisma client generado');
    
//     console.log('\n🚀 ¡Listo! Ahora puedes:');
//     console.log('1. Ejecutar migraciones: npx prisma migrate dev --name init');
//     console.log('2. Usar los servicios en tus API Routes o componentes');
//   } catch (error) {
//     console.error('❌ Error:', error);
//     process.exit(1);
//   }
// }

// run();


import fs from 'fs/promises';
import path from "path";
import { exec } from "child_process"
import { promisify }  from "util";


const execAsync = promisify(exec);

// Rutas
const PROJECT_ROOT = process.cwd();
const PRISMA_DIR = path.join(PROJECT_ROOT, 'prisma');
const TYPES_FILE = path.join(PROJECT_ROOT, 'types','types.ts');
const SERVICES_DIR = path.join(PROJECT_ROOT, 'services');
const SCHEMA_FILE = path.join(PRISMA_DIR, 'schema.prisma');

// Modelos y enums extraídos
let models = [];
let enums = [];

// === 1. Verificar si Prisma está inicializado ===
async function ensurePrismaInitialized() {
  try {
    await fs.access(PRISMA_DIR);
    console.log('✅ Prisma ya está inicializado');
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.log('🔧 Inicializando Prisma...');
      await execAsync('npx prisma init');
      console.log('✅ Prisma inicializado');
    } else {
      throw error;
    }
  }
}

// === 2. Leer y parsear types.ts ===
// async function parseTypesFile() {
//   try {
//     const data = await fs.readFile(TYPES_FILE, 'utf-8');
//     console.log('✅ Archivo types.ts leído correctamente');

//     // Extraer enums
//     const enumRegex = /enum\s+(\w+)\s*{([\s\S]*?)}/g;
//     let enumMatch;
//     while ((enumMatch = enumRegex.exec(data)) !== null) {
//       const name = enumMatch[1];
//       const values = enumMatch[2]
//         .split(',')
//         .map(v => v.trim())
//         .filter(v => v)
//         .map(v => v.split('=')[0].trim());
//       enums.push({ name, values });
//     }

//     // Extraer interfaces y type aliases
//     const typeInterfaceRegex = /(interface|type)\s+(\w+)\s*(?:=)?\s*{([\s\S]*?)}/g;
//     let match;
//     while ((match = typeInterfaceRegex.exec(data)) !== null) {
//       const typeName = match[2];
//       const body = match[3];

//       if (body.trim()) {
//         const fields = body
//           .split('\n')
//           .map(line => line.trim())
//           .filter(line => line && !line.startsWith('}'))
//           .map(line => {
//             const [name, type] = line.split(':').map(s => s.trim());
//             const isOptional = name.endsWith('?');
//             const fieldName = isOptional ? name.slice(0, -1) : name;
//             return { 
//               name: fieldName, 
//               type: type.replace(/;$/, '').replace(/\?$/, '').trim(),
//               optional: isOptional
//             };
//           });

//         models.push({ modelName: typeName, fields });
//       }
//     }

//     console.log(`✅ Modelos encontrados: ${models.map(m => m.modelName).join(', ')}`);
//     console.log(`✅ Enums encontrados: ${enums.map(e => e.name).join(', ')}`);
//   } catch (error) {
//     console.error('❌ No se encontró types.ts o tiene errores de sintaxis', error);
//     process.exit(1);
//   }
// }
// async function parseTypesFile() {
//   try {
//     const data = await fs.readFile(TYPES_FILE, 'utf-8');
//     console.log('✅ Archivo types.ts leído correctamente');

//     // Extraer enums
//     const enumRegex = /enum\s+(\w+)\s*{([\s\S]*?)}/g;
//     let enumMatch;
//     while ((enumMatch = enumRegex.exec(data)) !== null) {
//       const name = enumMatch[1];
//       const values = enumMatch[2]
//         .split(',')
//         .map(v => v.trim())
//         .filter(v => v)
//         .map(v => v.split('=')[0].trim());
//       enums.push({ name, values });
//     }

//     // Extraer interfaces y type aliases
//     const typeInterfaceRegex = /(interface|type)\s+(\w+)\s*(?:=)?\s*{([\s\S]*?)}/g;
//     let match;
//     while ((match = typeInterfaceRegex.exec(data)) !== null) {
//       const typeName = match[2];
//       const body = match[3];

//       if (body.trim()) {
//         const fields = body
//           .split('\n')
//           .map(line => line.trim())
//           .filter(line => line && !line.startsWith('}')) // Filtrar líneas vacías y llaves
//           .map(line => {
//             // Manejar campos con y sin signo de interrogación
//             const parts = line.split(':').map(s => s.trim());
//             if (parts.length < 2) return null; // Línea inválida

//             let [name, type] = parts;
//             const isOptional = name.endsWith('?');
//             const fieldName = isOptional ? name.slice(0, -1) : name;
//             const cleanedType = type.replace(/;$/, '').trim(); // Limpiar punto y coma final

//             return { 
//               name: fieldName, 
//               type: cleanedType,
//               optional: isOptional
//             };
//           })
//           .filter(field => field !== null); // Eliminar campos inválidos

//         models.push({ modelName: typeName, fields });
//       }
//     }

//     console.log(`✅ Modelos encontrados: ${models.map(m => m.modelName).join(', ')}`);
//     console.log(`✅ Enums encontrados: ${enums.map(e => e.name).join(', ')}`);
//   } catch (error) {
//     console.error('❌ No se encontró types.ts o tiene errores de sintaxis', error);
//     process.exit(1);
//   }
// }

async function parseTypesFile() {
  try {
    const data = await fs.readFile(TYPES_FILE, 'utf-8');
    console.log('✅ Archivo types.ts leído correctamente');

    // Eliminar comentarios inline antes de procesar
    const cleanData = data
      .replace(/\/\/.*$/gm, '')           // Comentarios de línea
      .replace(/\/\*[\s\S]*?\*\//g, '');  // Comentarios multilínea

    // Validar duplicados
    const modelNames = new Set();
    const enumNames = new Set();

    // Extraer enums
    const enumRegex = /enum\s+(\w+)\s*{([\s\S]*?)}/g;
    let enumMatch;
    while ((enumMatch = enumRegex.exec(cleanData)) !== null) {
      const name = enumMatch[1];
      
      if (enumNames.has(name)) {
        throw new Error(`❌ Duplicado: El enum "${name}" ya está definido`);
      }
      
      const values = enumMatch[2]
        .split(',')
        .map(v => v.trim())
        .filter(v => v)
        .map(v => v.split('=')[0].trim());
      
      enums.push({ name, values });
      enumNames.add(name);
    }

    // Extraer interfaces y type aliases
    const typeInterfaceRegex = /(interface|type)\s+(\w+)\s*(?:=)?\s*{([\s\S]*?)}/g;
    let match;
    while ((match = typeInterfaceRegex.exec(cleanData)) !== null) {
      const typeName = match[2];
      
      if (modelNames.has(typeName)) {
        throw new Error(`❌ Duplicado: El modelo "${typeName}" ya está definido`);
      }
      
      const body = match[3];

      if (body.trim()) {
        const fields = body
          .split('\n')
          .map(line => line.trim())
          .filter(line => line && !line.startsWith('}')) // Filtrar llaves
          .map(line => {
            // Validar formato de campo
            if (!/:/.test(line)) {
              console.warn(`⚠️ Formato inválido ignorado en ${typeName}: "${line}"`);
              return null;
            }

            const parts = line.split(':').map(s => s.trim());
            let [name, type] = parts;
            const isOptional = name.endsWith('?');
            const fieldName = isOptional ? name.slice(0, -1) : name;
            const cleanedType = type.replace(/;$/, '').trim();

            return { 
              name: fieldName, 
              type: cleanedType,
              optional: isOptional
            };
          })
          .filter(field => field !== null); // Eliminar campos inválidos

        models.push({ modelName: typeName, fields });
        modelNames.add(typeName);
      }
    }

    console.log(`✅ Modelos encontrados: ${models.map(m => m.modelName).join(', ')}`);
    console.log(`✅ Enums encontrados: ${enums.map(e => e.name).join(', ')}`);
  } catch (error) {
    console.error('❌ Error al procesar types.ts:', error.message);
    process.exit(1);
  }
}


// === 3. Generar schema.prisma ===
// async function generatePrismaSchema() {
//   let schemaContent = `
// generator client {
//   provider = "prisma-client-js"
// }

// datasource db {
//   provider = "postgresql"
//   url      = env("DATABASE_URL")
// }

// // === Enums generados ===
// `;

//   // Generar enums
//   enums.forEach(e => {
//     schemaContent += `enum ${e.name} {\n`;
//     e.values.forEach(v => schemaContent += `  ${v}\n`);
//     schemaContent += '}\n\n';
//   });

//   // Generar modelos
//   models.forEach(model => {
//     schemaContent += `\nmodel ${model.modelName} {\n`;
    
//     // Asegurar campo id
//     const idField = model.fields.find(f => f.name === 'id');
//     if (!idField) {
//       schemaContent += '  id String @id @default(cuid())\n';
//     }

//     model.fields.forEach(field => {
//       if (field.name === 'id') {
//         schemaContent += '  id String @id @default(cuid())\n';
//       } else {
//         const prismaType = mapToPrismaType(field.type);
//         const optional = field.optional ? '?' : '';
        
//         // Detectar relaciones (ej: userId -> User)
//         if (/Id$/.test(field.name) && models.some(m => m.modelName === field.type)) {
//           const relatedModel = field.type;
//           schemaContent += `  ${field.name} String\n`;
//           schemaContent += `  ${relatedModel.toLowerCase()} ${relatedModel} @relation(fields: [${field.name}], references: [id])\n`;
//         } else {
//           schemaContent += `  ${field.name} ${prismaType}${optional}\n`;
//         }
//       }
//     });

//     // Añadir campos comunes
//     schemaContent += '  createdAt DateTime @default(now())\n';
//     schemaContent += '  updatedAt DateTime @updatedAt\n';

//     schemaContent += '}\n';
//   });

//   await fs.writeFile(SCHEMA_FILE, schemaContent);
//   console.log('✅ schema.prisma generado');
// }
async function generatePrismaSchema() {
  let schemaContent = `
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// === Enums generados ===
`;

  // Generar enums
  enums.forEach(e => {
    schemaContent += `enum ${e.name} {\n`;
    e.values.forEach(v => schemaContent += `  ${v}\n`);
    schemaContent += '}\n\n';
  });

  // Generar modelos
  models.forEach(model => {
    schemaContent += `\nmodel ${model.modelName} {\n`;
    
    // Asegurar campo id
    const idField = model.fields.find(f => f.name === 'id');
    if (!idField) {
      schemaContent += '  id String @id @default(cuid())\n';
    }

    model.fields.forEach(field => {
      if (field.name === 'id') {
        schemaContent += '  id String @id @default(cuid())\n';
      } else {
        const prismaType = mapToPrismaType(field.type);
        const optional = field.optional ? '?' : '';
        
        // Detectar relaciones (ej: userId → User)
        if (/Id$/.test(field.name) && models.some(m => m.modelName === field.type)) {
          const relatedModel = field.type;
          schemaContent += `  ${field.name} String\n`;
          schemaContent += `  ${relatedModel.toLowerCase()} ${relatedModel} @relation(fields: [${field.name}], references: [id])\n`;
        } else {
          // Aplicar valores por defecto basados en el campo y tipo
          let defaultValue = '';
          
          // Ejemplo: campo "role" de tipo Role → default(USER)
          if (field.name === 'role' && prismaType === 'Role') {
            defaultValue = ' @default(USER)';
          } 
          
          // Puedes añadir más reglas aquí según tus necesidades
          // Ej: if (field.name === 'status' && prismaType === 'Status') { ... }

          schemaContent += `  ${field.name} ${prismaType}${optional}${defaultValue}\n`;
        }
      }
    });

    // Añadir campos comunes
    schemaContent += '  createdAt DateTime @default(now())\n';
    schemaContent += '  updatedAt DateTime @updatedAt\n';

    schemaContent += '}\n';
  });

  await fs.writeFile(SCHEMA_FILE, schemaContent);
  console.log('✅ schema.prisma generado');
}

// === 4. Mapear tipos de TS a Prisma ===
// function mapToPrismaType(tsType) {
//   const mapping = {
//     string: 'String',
//     number: 'Float',
//     boolean: 'Boolean',
//     Date: 'DateTime'
//   };
  
//   return mapping[tsType] || 'String'; // Por defecto
// }
// function mapToPrismaType(tsType) {
//   // Tipos básicos
//   const baseTypes = {
//     string: 'String',
//     number: 'Float',
//     boolean: 'Boolean',
//     Date: 'DateTime'
//   };

//   // Detectar arrays (Array<string> → String[])
//   const arrayMatch = tsType.match(/Array<(\w+)>/);
//   if (arrayMatch) {
//     const elementType = arrayMatch[1];
//     return `${baseTypes[elementType] || elementType}[]`;
//   }

//   // Tipos básicos directos
//   if (baseTypes[tsType]) {
//     return baseTypes[tsType];
//   }

//   // Relaciones (ej: User → User)
//   if (models.some(m => m.modelName === tsType)) {
//     return tsType;
//   }

//   // Tipo desconocido (fallback)
//   console.warn(`⚠️ Tipo desconocido: "${tsType}"`);
//   return 'Json'; // Fallback seguro
// }
function mapToPrismaType(tsType) {
  // Tipos básicos
  const baseTypes = {
    string: 'String',
    number: 'Float',
    boolean: 'Boolean',
    Date: 'DateTime'
  };

  // Detectar arrays (Array<string> → String[])
  const arrayMatch = tsType.match(/Array<(\w+)>/);
  if (arrayMatch) {
    const elementType = arrayMatch[1];
    return `${baseTypes[elementType] || elementType}[]`;
  }

  // Tipos básicos directos
  if (baseTypes[tsType]) {
    return baseTypes[tsType];
  }

  // Verificar si es un enum definido
  const foundEnum = enums.find(e => e.name === tsType);
  if (foundEnum) {
    return tsType; // En Prisma, el tipo es el nombre del enum
  }

  // Relaciones (ej: User → User)
  if (models.some(m => m.modelName === tsType)) {
    return tsType;
  }

  // Tipo desconocido (fallback)
  console.warn(`⚠️ Tipo desconocido: "${tsType}"`);
  return 'Json'; // Fallback seguro
}

// === 5. Crear servicios CRUD ===
async function generateServices() {
  await fs.mkdir(SERVICES_DIR, { recursive: true });
  
  for (const model of models) {
    const { modelName, fields } = model;
    const lowerName = modelName.toLowerCase();
    
    const serviceContent = `
import { prisma } from '../lib/prisma';

// Tipos generados
export type ${modelName} = {
  id: string;
  ${fields
    .filter(f => f.name !== 'id')
    .map(f => `${f.name}${f.optional ? '?' : ''}: ${mapToPrismaType(f.type).replace('[]', '[] | null')}`)
    .join(';\n  ')}
  createdAt: string;
  updatedAt: string;
};

// Servicios CRUD
export const getAll${modelName}s = async () => {
  return await prisma.${lowerName}.findMany();
};

export const get${modelName}ById = async (id: string) => {
  return await prisma.${lowerName}.findUnique({ where: { id } });
};

export const create${modelName} = async (data: Omit<${modelName}, 'id'>) => {
  return await prisma.${lowerName}.create({ data });
};

export const update${modelName} = async (id: string, data: Partial<${modelName}>) => {
  return await prisma.${lowerName}.update({ where: { id }, data });
};

export const delete${modelName} = async (id: string) => {
  return await prisma.${lowerName}.delete({ where: { id } });
};
    `;
    
    await fs.writeFile(path.join(SERVICES_DIR, `${modelName}Service.ts`), serviceContent.trim());
  }
  
  // Crear index.ts para exportar todos los servicios
  const indexContent = models.map(model => 
    `export * from './${model.modelName}Service';`
  ).join('\n');
  
  await fs.writeFile(path.join(SERVICES_DIR, 'index.ts'), indexContent);
  console.log('✅ Servicios generados');
}

// === 6. Crear cliente de Prisma ===
async function createPrismaClient() {
  const libDir = path.join(PROJECT_ROOT, 'lib');
  const clientFile = path.join(libDir, 'prisma.ts');
  
  const clientContent = `
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export { prisma };
  `;
  
  await fs.mkdir(libDir, { recursive: true });
  await fs.writeFile(clientFile, clientContent.trim());
  console.log('✅ Cliente de Prisma creado');
}

// === 7. Ejecutar flujo ===
  async function run() {
  try {
    await ensurePrismaInitialized();
    await parseTypesFile();
    await generatePrismaSchema();
    await createPrismaClient();
    await generateServices();  
    
    console.log('\n🚀 ¡Listo! Ahora puedes:');
    console.log('1. Ejecutar migraciones: npx prisma migrate dev --name init');
    console.log('2. Usar los servicios en tus API Routes o componentes');
  } catch (error) {
    console.error('❌ Error:', error.message);
    process.exit(1);
  }
}

run();